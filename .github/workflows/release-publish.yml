# iOS Release Pipeline
#
# This workflow automates iOS app releases to TestFlight Public Beta.
# It can also submit directly to the App Store for review.
#
# Trigger modes:
# 1. Automatic: Push to main that modifies Version.xcconfig
# 2. Manual: workflow_dispatch with submit_for_review option

name: Release & Publish

on:
  workflow_dispatch:
    inputs:
      submit_for_review:
        description: "Submit to App Store for review after upload"
        required: false
        default: false
        type: boolean

permissions:
  contents: write

# Cancel in-progress releases when a new version is triggered
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

env:
  DEVELOPER_DIR: /Applications/Xcode.app/Contents/Developer

jobs:
  branch-guard:
    name: Verify Main Branch
    runs-on: ubuntu-latest
    steps:
      - name: Block non-main branches
        run: |
          echo "Current branch: $GITHUB_REF_NAME"
          if [ "$GITHUB_REF_NAME" != "main" ]; then
            echo "::error::Release workflow must be run from the main branch. Current branch: $GITHUB_REF_NAME"
            exit 1
          fi
          echo "Branch verified: main"

  version-check:
    name: Check Version and Create Tag
    needs: branch-guard
    runs-on: ubuntu-latest

    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      new_tag: ${{ steps.check.outputs.new_tag }}
      version: ${{ steps.check.outputs.version }}
      build: ${{ steps.check.outputs.build }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.ORG_ADMIN_TOKEN }}

      - name: Increment build number and check version
        id: check
        run: |
          CURRENT_VERSION=$(grep '^MARKETING_VERSION = ' Version.xcconfig | sed 's/.*MARKETING_VERSION = //' | xargs)
          CURRENT_BUILD=$(grep '^CURRENT_PROJECT_VERSION = ' Version.xcconfig | sed 's/.*CURRENT_PROJECT_VERSION = //' | xargs)

          # Auto-increment build number
          NEW_BUILD=$((CURRENT_BUILD + 1))
          echo "Version: $CURRENT_VERSION"
          echo "Build number: $CURRENT_BUILD â†’ $NEW_BUILD"

          # Update Version.xcconfig with new build number
          sed -i "s/^CURRENT_PROJECT_VERSION = .*/CURRENT_PROJECT_VERSION = $NEW_BUILD/" Version.xcconfig

          # Commit and push the build number increment to main
          # Uses ORG_ADMIN_TOKEN (via checkout) to bypass branch protection
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add Version.xcconfig
          git commit -m "chore: bump build number to $NEW_BUILD"
          git push origin HEAD:main

          TAG_NAME="v$CURRENT_VERSION"

          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "Tag $TAG_NAME exists, deleting for re-release"
            git push origin --delete "$TAG_NAME" 2>/dev/null || true
          else
            echo "Tag $TAG_NAME does not exist, will create it"
          fi
          echo "should_release=true" >> $GITHUB_OUTPUT

          echo "new_tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "build=$NEW_BUILD" >> $GITHUB_OUTPUT

      - name: Create and push tag
        if: steps.check.outputs.should_release == 'true'
        env:
          TAG_NAME: ${{ steps.check.outputs.new_tag }}
          VERSION: ${{ steps.check.outputs.version }}
          BUILD: ${{ steps.check.outputs.build }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          git tag -d "$TAG_NAME" 2>/dev/null || true
          git tag -a "$TAG_NAME" -m "Release version $VERSION (build $BUILD)"
          git push origin "$TAG_NAME"

          echo "Successfully created tag: $TAG_NAME"

  build-and-release:
    name: Build and Release to TestFlight
    needs: version-check
    if: needs.version-check.outputs.should_release == 'true'
    runs-on: macos-26

    steps:
      - name: Checkout repository at tag
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
          ref: ${{ needs.version-check.outputs.new_tag }}

      - name: Select Xcode version
        run: sudo xcode-select -s /Applications/Xcode_26.0.1.app/Contents/Developer

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: false

      - name: Install Fastlane
        run: |
          gem install fastlane --no-document
          gem install xcpretty --no-document

          echo ""
          echo "Build tools ready:"
          echo "  Fastlane: $(fastlane --version | tail -n 1)"
          echo "  Xcode: $(xcodebuild -version | head -1)"
          echo "  Ruby: $(ruby --version)"

      - name: Setup SSH for Match repository
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.ORG_DEPLOY_KEY || secrets.DEPLOY_KEY }}

      # Clean up stale keychains from previous failed runs
      - name: Clean stale keychains
        run: |
          echo "Cleaning up stale keychains from previous runs..."
          STALE_PATHS=(
            "$HOME/Library/Keychains/fastlane_tmp_keychain-db"
            "$HOME/Library/Keychains/fastlane_tmp_keychain"
          )
          for KC in "${STALE_PATHS[@]}"; do
            if [ -f "$KC" ]; then
              echo "Removing stale keychain: $KC"
              security delete-keychain "$KC" 2>/dev/null || rm -f "$KC"
            fi
          done
          echo "Stale keychain cleanup complete"

      # Install Apple WWDR intermediate certificates for code signing chain validation
      - name: Install Apple WWDR Certificates
        run: |
          echo "Downloading Apple WWDR intermediate certificates..."
          mkdir -p /tmp/apple-certs

          curl -sL https://www.apple.com/certificateauthority/AppleWWDRCAG3.cer -o /tmp/apple-certs/AppleWWDRCAG3.cer
          curl -sL https://www.apple.com/certificateauthority/AppleWWDRCAG4.cer -o /tmp/apple-certs/AppleWWDRCAG4.cer
          curl -sL https://developer.apple.com/certificationauthority/AppleWWDRCA.cer -o /tmp/apple-certs/AppleWWDRCA.cer

          echo "Importing WWDR certificates to login keychain..."
          security import /tmp/apple-certs/AppleWWDRCAG3.cer -k ~/Library/Keychains/login.keychain-db -T /usr/bin/codesign -T /usr/bin/security || true
          security import /tmp/apple-certs/AppleWWDRCAG4.cer -k ~/Library/Keychains/login.keychain-db -T /usr/bin/codesign -T /usr/bin/security || true
          security import /tmp/apple-certs/AppleWWDRCA.cer -k ~/Library/Keychains/login.keychain-db -T /usr/bin/codesign -T /usr/bin/security || true

          echo "WWDR certificates installed successfully"

      - name: Create App Store Connect API Key
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.ORG_APP_STORE_CONNECT_KEY_ID || secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.ORG_APP_STORE_CONNECT_ISSUER_ID || secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_BASE64: ${{ secrets.ORG_APP_STORE_CONNECT_API_KEY_BASE64 || secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}
        run: |
          # Validate secrets
          for var in APP_STORE_CONNECT_KEY_ID APP_STORE_CONNECT_ISSUER_ID APP_STORE_CONNECT_API_KEY_BASE64; do
            if [ -z "${!var}" ]; then
              echo "ERROR: $var is not set"
              exit 1
            fi
            echo "$var is set"
          done

          # Create API key file
          mkdir -p ~/.appstoreconnect/private_keys
          KEY_PATH=~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8

          # Decode base64 with fallback methods
          DECODE_SUCCESS=false

          if echo "$APP_STORE_CONNECT_API_KEY_BASE64" | base64 -d > "$KEY_PATH" 2>/dev/null; then
            DECODE_SUCCESS=true
          elif echo "$APP_STORE_CONNECT_API_KEY_BASE64" | base64 --decode > "$KEY_PATH" 2>/dev/null; then
            DECODE_SUCCESS=true
          elif echo "$APP_STORE_CONNECT_API_KEY_BASE64" | tr -d '\n\r ' | base64 -d > "$KEY_PATH" 2>/dev/null; then
            DECODE_SUCCESS=true
          fi

          if [ "$DECODE_SUCCESS" = false ] || [ ! -s "$KEY_PATH" ]; then
            echo "ERROR: Failed to decode API key"
            exit 1
          fi

          chmod 600 "$KEY_PATH"
          echo "API key file created successfully"

          echo "APP_STORE_CONNECT_API_KEY_KEY_ID=$APP_STORE_CONNECT_KEY_ID" >> $GITHUB_ENV
          echo "APP_STORE_CONNECT_API_KEY_ISSUER_ID=$APP_STORE_CONNECT_ISSUER_ID" >> $GITHUB_ENV
          echo "APP_STORE_CONNECT_API_KEY_KEY=$KEY_PATH" >> $GITHUB_ENV

      - name: Build iOS
        timeout-minutes: 45
        env:
          MATCH_PASSWORD: ${{ secrets.ORG_MATCH_PASSWORD || secrets.MATCH_PASSWORD }}
          ORG_MATCH_GIT_URL: ${{ secrets.ORG_MATCH_GIT_URL || secrets.MATCH_GIT_URL }}
          ORG_TEAM_ID: ${{ secrets.ORG_TEAM_ID || secrets.TEAM_ID }}
          FASTLANE_VERBOSE: true
          LC_ALL: en_US.UTF-8
          LANG: en_US.UTF-8
        run: |
          echo "========================================="
          echo "Build Environment:"
          echo "========================================="
          echo "Ruby: $(ruby --version)"
          echo "Fastlane: $(fastlane --version | tail -n 1)"
          echo "Xcode: $(xcodebuild -version | head -1)"
          echo "========================================="

          fastlane build_beta

      - name: Upload to TestFlight
        timeout-minutes: 30
        env:
          ORG_TEAM_ID: ${{ secrets.ORG_TEAM_ID || secrets.TEAM_ID }}
          SUBMIT_FOR_REVIEW: ${{ inputs.submit_for_review }}
          FASTLANE_VERBOSE: true
          LC_ALL: en_US.UTF-8
          LANG: en_US.UTF-8
        run: |
          fastlane upload_beta

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.version-check.outputs.new_tag }}
          name: Release ${{ needs.version-check.outputs.version }}
          body: |
            ## Version ${{ needs.version-check.outputs.version }}
            Build: ${{ needs.version-check.outputs.build }}

            ### Distribution
            ${{ inputs.submit_for_review == true && 'This version has been uploaded and submitted for App Store review.' || 'This version has been automatically submitted to TestFlight for public beta testing.' }}

            ### What's New
            - See [commit history](https://github.com/${{ github.repository }}/commits/${{ needs.version-check.outputs.new_tag }}) for changes

            ---
            *This release was automatically created by GitHub Actions*
          draft: false
          prerelease: false

      - name: Post release notification
        if: success()
        env:
          SUBMIT_FOR_REVIEW: ${{ inputs.submit_for_review }}
          RELEASE_VERSION: ${{ needs.version-check.outputs.version }}
          RELEASE_TAG: ${{ needs.version-check.outputs.new_tag }}
          RELEASE_BUILD: ${{ needs.version-check.outputs.build }}
        run: |
          if [ "$SUBMIT_FOR_REVIEW" = "true" ]; then
            echo "Successfully submitted version $RELEASE_VERSION for App Store review!"
          else
            echo "Successfully released version $RELEASE_VERSION to TestFlight!"
          fi
          echo "Tag: $RELEASE_TAG"
          echo "Build: $RELEASE_BUILD"

      - name: Cleanup CI Keychain
        if: always()
        run: |
          echo "Cleaning up temporary keychains (if any)..."

          KEYCHAIN_PATHS=(
            "$HOME/Library/Keychains/fastlane_tmp_keychain-db"
            "$HOME/Library/Keychains/fastlane_tmp_keychain"
          )

          CLEANED=0
          for KEYCHAIN_PATH in "${KEYCHAIN_PATHS[@]}"; do
            if [ -f "$KEYCHAIN_PATH" ]; then
              security list-keychains -d user -s login.keychain-db 2>&1 || true
              security lock-keychain "$KEYCHAIN_PATH" 2>&1 || true
              security delete-keychain "$KEYCHAIN_PATH" 2>&1 || true
              rm -f "$KEYCHAIN_PATH" 2>&1 || true
              CLEANED=$((CLEANED + 1))
            fi
          done

          if [ $CLEANED -gt 0 ]; then
            echo "Cleaned up $CLEANED temporary keychain(s)"
          else
            echo "No temporary keychains found"
          fi
