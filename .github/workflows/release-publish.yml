# iOS Release Pipeline
#
# This workflow automates iOS app releases to TestFlight Public Beta.
# It can also submit directly to the App Store for review.
#
# Trigger modes:
# 1. Automatic: Push to main that modifies Version.xcconfig
# 2. Manual: workflow_dispatch with force_release and submit_for_review options

name: Release & Publish

on:
  workflow_dispatch:
    inputs:
      force_release:
        description: "Force release even if version unchanged"
        required: false
        default: true
        type: boolean
      submit_for_review:
        description: "Submit to App Store for review after upload"
        required: false
        default: false
        type: boolean

permissions:
  contents: write

# Cancel in-progress releases when a new version is triggered
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

env:
  DEVELOPER_DIR: /Applications/Xcode.app/Contents/Developer

jobs:
  branch-guard:
    name: Verify Main Branch
    runs-on: ubuntu-latest
    steps:
      - name: Block non-main branches
        run: |
          echo "Current branch: $GITHUB_REF_NAME"
          if [ "$GITHUB_REF_NAME" != "main" ]; then
            echo "::error::Release workflow must be run from the main branch. Current branch: $GITHUB_REF_NAME"
            exit 1
          fi
          echo "Branch verified: main"

  validate-secrets:
    name: Validate Required Secrets
    needs: branch-guard
    runs-on: ubuntu-latest

    outputs:
      secrets_valid: ${{ steps.check.outputs.secrets_valid }}

    steps:
      - name: Check required secrets
        id: check
        env:
          HAS_DEPLOY_KEY: ${{ secrets.ORG_DEPLOY_KEY != '' }}
          HAS_MATCH_PASSWORD: ${{ secrets.ORG_MATCH_PASSWORD != '' }}
          HAS_MATCH_GIT_URL: ${{ secrets.ORG_MATCH_GIT_URL != '' }}
          HAS_TEAM_ID: ${{ secrets.ORG_TEAM_ID != '' }}
          HAS_ASC_KEY_ID: ${{ secrets.ORG_APP_STORE_CONNECT_KEY_ID != '' }}
          HAS_ASC_ISSUER_ID: ${{ secrets.ORG_APP_STORE_CONNECT_ISSUER_ID != '' }}
          HAS_ASC_API_KEY: ${{ secrets.ORG_APP_STORE_CONNECT_API_KEY_BASE64 != '' }}
        run: |
          echo "Checking required secrets..."
          ALL_VALID=true

          check_secret() {
            local name="$1"
            local value="$2"
            local required="$3"

            if [ "$value" = "true" ]; then
              echo "  $name ... present"
            elif [ "$required" = "true" ]; then
              echo "::error::Required secret '$name' is missing"
              ALL_VALID=false
            else
              echo "::warning::Optional secret '$name' is missing"
            fi
          }

          check_secret "ORG_DEPLOY_KEY" "$HAS_DEPLOY_KEY" "true"
          check_secret "ORG_MATCH_PASSWORD" "$HAS_MATCH_PASSWORD" "true"
          check_secret "ORG_MATCH_GIT_URL" "$HAS_MATCH_GIT_URL" "true"
          check_secret "ORG_TEAM_ID" "$HAS_TEAM_ID" "true"
          check_secret "ORG_APP_STORE_CONNECT_KEY_ID" "$HAS_ASC_KEY_ID" "true"
          check_secret "ORG_APP_STORE_CONNECT_ISSUER_ID" "$HAS_ASC_ISSUER_ID" "true"
          check_secret "ORG_APP_STORE_CONNECT_API_KEY_BASE64" "$HAS_ASC_API_KEY" "true"

          if [ "$ALL_VALID" = "true" ]; then
            echo "secrets_valid=true" >> $GITHUB_OUTPUT
            echo "All required secrets are configured"
          else
            echo "secrets_valid=false" >> $GITHUB_OUTPUT
            echo "::error::Some required secrets are missing. Please configure them in repository settings."
            exit 1
          fi

  version-check:
    name: Check Version and Create Tag
    needs: validate-secrets
    if: needs.validate-secrets.outputs.secrets_valid == 'true'
    runs-on: ubuntu-latest

    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      new_tag: ${{ steps.check.outputs.new_tag }}
      version: ${{ steps.check.outputs.version }}
      build: ${{ steps.check.outputs.build }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check version and create tag if needed
        id: check
        env:
          FORCE_RELEASE: ${{ inputs.force_release }}
        run: |
          CURRENT_VERSION=$(grep '^MARKETING_VERSION = ' Version.xcconfig | sed 's/.*MARKETING_VERSION = //' | xargs)
          CURRENT_BUILD=$(grep '^CURRENT_PROJECT_VERSION = ' Version.xcconfig | sed 's/.*CURRENT_PROJECT_VERSION = //' | xargs)

          echo "Current version: $CURRENT_VERSION (build $CURRENT_BUILD)"

          TAG_NAME="v$CURRENT_VERSION"

          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            if [[ "$FORCE_RELEASE" == "true" ]]; then
              echo "Tag $TAG_NAME exists but force_release is true"
              git push origin --delete "$TAG_NAME" 2>/dev/null || true
              echo "should_release=true" >> $GITHUB_OUTPUT
            else
              echo "Tag $TAG_NAME already exists, skipping release"
              echo "should_release=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "Tag $TAG_NAME does not exist, will create it"
            echo "should_release=true" >> $GITHUB_OUTPUT
          fi

          echo "new_tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "build=$CURRENT_BUILD" >> $GITHUB_OUTPUT

      - name: Create and push tag
        if: steps.check.outputs.should_release == 'true'
        env:
          TAG_NAME: ${{ steps.check.outputs.new_tag }}
          VERSION: ${{ steps.check.outputs.version }}
          BUILD: ${{ steps.check.outputs.build }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          git tag -d "$TAG_NAME" 2>/dev/null || true
          git tag -a "$TAG_NAME" -m "Release version $VERSION (build $BUILD)"
          git push origin "$TAG_NAME"

          echo "Successfully created tag: $TAG_NAME"

  build-and-release:
    name: Build and Release to TestFlight
    needs: version-check
    if: needs.version-check.outputs.should_release == 'true'
    runs-on: macos-26

    steps:
      - name: Checkout repository at tag
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
          ref: ${{ needs.version-check.outputs.new_tag }}

      - name: Select Xcode version
        run: sudo xcode-select -s /Applications/Xcode_26.0.1.app/Contents/Developer

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: false

      - name: Install Fastlane
        run: |
          gem install fastlane -v 2.231.1
          gem install xcpretty

      - name: Setup SSH for Match repository
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.ORG_DEPLOY_KEY || secrets.DEPLOY_KEY }}

      # Clean up stale keychains from previous failed runs
      - name: Clean stale keychains
        run: |
          echo "Cleaning up stale keychains from previous runs..."
          STALE_PATHS=(
            "$HOME/Library/Keychains/fastlane_tmp_keychain-db"
            "$HOME/Library/Keychains/fastlane_tmp_keychain"
          )
          for KC in "${STALE_PATHS[@]}"; do
            if [ -f "$KC" ]; then
              echo "Removing stale keychain: $KC"
              security delete-keychain "$KC" 2>/dev/null || rm -f "$KC"
            fi
          done
          echo "Stale keychain cleanup complete"

      # Install Apple WWDR intermediate certificates for code signing chain validation
      - name: Install Apple WWDR Certificates
        run: |
          echo "Downloading Apple WWDR intermediate certificates..."
          mkdir -p /tmp/apple-certs

          curl -sL https://www.apple.com/certificateauthority/AppleWWDRCAG3.cer -o /tmp/apple-certs/AppleWWDRCAG3.cer
          curl -sL https://www.apple.com/certificateauthority/AppleWWDRCAG4.cer -o /tmp/apple-certs/AppleWWDRCAG4.cer
          curl -sL https://developer.apple.com/certificationauthority/AppleWWDRCA.cer -o /tmp/apple-certs/AppleWWDRCA.cer

          echo "Importing WWDR certificates to login keychain..."
          security import /tmp/apple-certs/AppleWWDRCAG3.cer -k ~/Library/Keychains/login.keychain-db -T /usr/bin/codesign -T /usr/bin/security || true
          security import /tmp/apple-certs/AppleWWDRCAG4.cer -k ~/Library/Keychains/login.keychain-db -T /usr/bin/codesign -T /usr/bin/security || true
          security import /tmp/apple-certs/AppleWWDRCA.cer -k ~/Library/Keychains/login.keychain-db -T /usr/bin/codesign -T /usr/bin/security || true

          echo "WWDR certificates installed successfully"

      - name: Create App Store Connect API Key
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.ORG_APP_STORE_CONNECT_KEY_ID || secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.ORG_APP_STORE_CONNECT_ISSUER_ID || secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_BASE64: ${{ secrets.ORG_APP_STORE_CONNECT_API_KEY_BASE64 || secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}
        run: |
          # Validate secrets
          for var in APP_STORE_CONNECT_KEY_ID APP_STORE_CONNECT_ISSUER_ID APP_STORE_CONNECT_API_KEY_BASE64; do
            if [ -z "${!var}" ]; then
              echo "ERROR: $var is not set"
              exit 1
            fi
            echo "$var is set"
          done

          # Create API key file
          mkdir -p ~/.appstoreconnect/private_keys
          KEY_PATH=~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8

          # Decode base64 with fallback methods
          DECODE_SUCCESS=false

          if echo "$APP_STORE_CONNECT_API_KEY_BASE64" | base64 -d > "$KEY_PATH" 2>/dev/null; then
            DECODE_SUCCESS=true
          elif echo "$APP_STORE_CONNECT_API_KEY_BASE64" | base64 --decode > "$KEY_PATH" 2>/dev/null; then
            DECODE_SUCCESS=true
          elif echo "$APP_STORE_CONNECT_API_KEY_BASE64" | tr -d '\n\r ' | base64 -d > "$KEY_PATH" 2>/dev/null; then
            DECODE_SUCCESS=true
          fi

          if [ "$DECODE_SUCCESS" = false ] || [ ! -s "$KEY_PATH" ]; then
            echo "ERROR: Failed to decode API key"
            exit 1
          fi

          chmod 600 "$KEY_PATH"
          echo "API key file created successfully"

          echo "APP_STORE_CONNECT_API_KEY_KEY_ID=$APP_STORE_CONNECT_KEY_ID" >> $GITHUB_ENV
          echo "APP_STORE_CONNECT_API_KEY_ISSUER_ID=$APP_STORE_CONNECT_ISSUER_ID" >> $GITHUB_ENV
          echo "APP_STORE_CONNECT_API_KEY_KEY=$KEY_PATH" >> $GITHUB_ENV

      - name: Build and Upload to TestFlight
        timeout-minutes: 60
        env:
          MATCH_PASSWORD: ${{ secrets.ORG_MATCH_PASSWORD || secrets.MATCH_PASSWORD }}
          ORG_MATCH_GIT_URL: ${{ secrets.ORG_MATCH_GIT_URL || secrets.MATCH_GIT_URL }}
          ORG_TEAM_ID: ${{ secrets.ORG_TEAM_ID || secrets.TEAM_ID }}
          SUBMIT_FOR_REVIEW: ${{ inputs.submit_for_review }}
          FASTLANE_VERBOSE: true
          LC_ALL: en_US.UTF-8
          LANG: en_US.UTF-8
        run: |
          echo "========================================="
          echo "Build Environment:"
          echo "========================================="
          echo "Ruby: $(ruby --version)"
          echo "Fastlane: $(fastlane --version | tail -n 1)"
          echo "Xcode: $(xcodebuild -version | head -1)"
          echo "Submit for review: $SUBMIT_FOR_REVIEW"
          echo "========================================="

          fastlane beta

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.version-check.outputs.new_tag }}
          name: Release ${{ needs.version-check.outputs.version }}
          body: |
            ## Version ${{ needs.version-check.outputs.version }}
            Build: ${{ needs.version-check.outputs.build }}

            ### Distribution
            ${{ inputs.submit_for_review == true && 'This version has been uploaded and submitted for App Store review.' || 'This version has been automatically submitted to TestFlight for public beta testing.' }}

            ### What's New
            - See [commit history](https://github.com/${{ github.repository }}/commits/${{ needs.version-check.outputs.new_tag }}) for changes

            ---
            *This release was automatically created by GitHub Actions*
          draft: false
          prerelease: false

      - name: Post release notification
        if: success()
        env:
          SUBMIT_FOR_REVIEW: ${{ inputs.submit_for_review }}
          RELEASE_VERSION: ${{ needs.version-check.outputs.version }}
          RELEASE_TAG: ${{ needs.version-check.outputs.new_tag }}
          RELEASE_BUILD: ${{ needs.version-check.outputs.build }}
        run: |
          if [ "$SUBMIT_FOR_REVIEW" = "true" ]; then
            echo "Successfully submitted version $RELEASE_VERSION for App Store review!"
          else
            echo "Successfully released version $RELEASE_VERSION to TestFlight!"
          fi
          echo "Tag: $RELEASE_TAG"
          echo "Build: $RELEASE_BUILD"

      - name: Cleanup CI Keychain
        if: always()
        run: |
          echo "Cleaning up temporary keychains (if any)..."

          KEYCHAIN_PATHS=(
            "$HOME/Library/Keychains/fastlane_tmp_keychain-db"
            "$HOME/Library/Keychains/fastlane_tmp_keychain"
          )

          CLEANED=0
          for KEYCHAIN_PATH in "${KEYCHAIN_PATHS[@]}"; do
            if [ -f "$KEYCHAIN_PATH" ]; then
              security list-keychains -d user -s login.keychain-db 2>&1 || true
              security lock-keychain "$KEYCHAIN_PATH" 2>&1 || true
              security delete-keychain "$KEYCHAIN_PATH" 2>&1 || true
              rm -f "$KEYCHAIN_PATH" 2>&1 || true
              CLEANED=$((CLEANED + 1))
            fi
          done

          if [ $CLEANED -gt 0 ]; then
            echo "Cleaned up $CLEANED temporary keychain(s)"
          else
            echo "No temporary keychains found"
          fi
