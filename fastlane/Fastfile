# Fastfile for V2er iOS app

require 'shellwords'
require 'fileutils'
# Import changelog helper
require_relative 'changelog_helper'

# Ignore malformed version strings from App Store Connect (e.g. "1.2..8")
original_gem_version_new = Gem::Version.method(:new)
Gem::Version.define_singleton_method(:new) do |version|
  original_gem_version_new.call(version)
rescue ArgumentError
  original_gem_version_new.call("0")
end

default_platform(:ios)

platform :ios do
  # Helper method to get App Store Connect API key
  private_lane :get_api_key do
    # Check if running in CI or local
    if ENV["APP_STORE_CONNECT_API_KEY_KEY"]
      # CI environment with key file path
      key_content = File.read(ENV["APP_STORE_CONNECT_API_KEY_KEY"])
    elsif ENV["ORG_APP_STORE_CONNECT_API_KEY_BASE64"]
      # Local environment with key content directly
      key_content = ENV["ORG_APP_STORE_CONNECT_API_KEY_BASE64"]
    elsif ENV["APP_STORE_CONNECT_API_KEY_CONTENT"]
      # Legacy local environment variable
      key_content = ENV["APP_STORE_CONNECT_API_KEY_CONTENT"]
    else
      # Try to read from standard location
      key_id = ENV["ORG_APP_STORE_CONNECT_KEY_ID"] || ENV["APP_STORE_CONNECT_KEY_ID"]
      key_path = File.expand_path("~/.appstoreconnect/private_keys/AuthKey_#{key_id}.p8")
      if File.exist?(key_path)
        key_content = File.read(key_path)
      else
        UI.user_error!("App Store Connect API key not found. Please set APP_STORE_CONNECT_API_KEY_CONTENT environment variable or place the key at #{key_path}")
      end
    end

    app_store_connect_api_key(
      key_id: ENV["ORG_APP_STORE_CONNECT_KEY_ID"] || ENV["APP_STORE_CONNECT_KEY_ID"] || ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
      issuer_id: ENV["ORG_APP_STORE_CONNECT_ISSUER_ID"] || ENV["APP_STORE_CONNECT_ISSUER_ID"] || ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
      key_content: key_content,
      in_house: false
    )
  end

  # Helper method to get consistent keychain path across all operations
  private_lane :get_ci_keychain_path do
    path = ENV["MATCH_KEYCHAIN_PATH"] || ENV["KEYCHAIN_PATH"] || "~/Library/Keychains/fastlane_tmp_keychain-db"
    File.expand_path(path)
  end

  # Helper method for building the app
  private_lane :build_ipa do |options|
    # Get profile name from match context or use default
    profile_name = options[:profile_name] || ENV["sigh_v2er.app_appstore_profile-name"] || "match AppStore v2er.app"

    # Build xcargs with keychain path for CI to prevent errSecInternalComponent
    xcargs = "-allowProvisioningUpdates CODE_SIGN_STYLE=Manual"
    if is_ci
      keychain_path = get_ci_keychain_path
      xcargs += " OTHER_CODE_SIGN_FLAGS=--keychain\\ #{Shellwords.escape(keychain_path)}"
    end

    build_app(
      scheme: "V2er-iOS",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "v2er.app" => profile_name
        },
        teamID: ENV["ORG_TEAM_ID"] || ENV["TEAM_ID"]
      },
      export_team_id: ENV["ORG_TEAM_ID"] || ENV["TEAM_ID"],
      xcargs: xcargs,
      clean: true,
      output_directory: "./build",
      output_name: "V2er.ipa",
      verbose: true,
      buildlog_path: "./buildlog",
      silent: false
    )
  end

  desc "Sync certificates and provisioning profiles"
  lane :sync_certificates do
    match_options = {
      type: "appstore",
      readonly: is_ci,
      app_identifier: "v2er.app",
      git_url: ENV["ORG_MATCH_GIT_URL"] || ENV["MATCH_GIT_URL"] || "git@github.com:graycreate/ios-certificates.git"
    }

    if ENV["MATCH_KEYCHAIN_NAME"]
      match_options[:keychain_name] = ENV["MATCH_KEYCHAIN_NAME"]
      match_options[:keychain_password] = ENV["MATCH_KEYCHAIN_PASSWORD"] if ENV["MATCH_KEYCHAIN_PASSWORD"]
    end

    match(match_options)
  end

  desc "Distribute existing build to beta testers"
  lane :distribute_beta do |options|
    # Get App Store Connect API key
    api_key = get_api_key

    # Get the build number to distribute (optional)
    build_number = options[:build_number]

    begin
      # Distribute to beta testers
      testflight(
        api_key: api_key,
        app_identifier: "v2er.app",
        skip_submission: false,
        distribute_external: true,  # Distribute to external testers (public beta)
        groups: ["Public Beta", "External Testers", "Beta Testers"],  # Public beta groups
        notify_external_testers: true,  # Send email notifications
        uses_non_exempt_encryption: false,
        submit_beta_review: true,  # Automatically submit for Beta review
        wait_for_uploaded_build: true,
        beta_app_description: "V2er is an elegant third-party client for V2EX forum",
        beta_app_feedback_email: "hi@v2er.app",
        demo_account_required: false,
        beta_app_review_info: {
          contact_email: "hi@v2er.app",
          contact_first_name: "V2er",
          contact_last_name: "Support",
          contact_phone: "+86 13800138000",
          notes: "This is a third-party client app for V2EX forum. No special account needed for testing."
        }
      )

      UI.success("Successfully distributed build to beta testers!")
    rescue => e
      UI.error("Failed to distribute: #{e.message}")
      UI.message("You may need to manually distribute the build in App Store Connect")
    end
  end

  desc "Build iOS app (does not upload)"
  lane :build_beta do
    # Setup CI environment
    # Uses create_keychain directly instead of setup_ci to avoid renaming login.keychain-db.
    # setup_ci hardcodes default_keychain: true, which renames the login keychain and breaks
    # self-hosted runners when CI jobs fail without proper cleanup.
    if ENV['CI']
      keychain_name = "fastlane_tmp_keychain"
      keychain_password = ""
      keychain_path = File.expand_path("~/Library/Keychains/#{keychain_name}-db")

      # Clean up stale keychain from previous failed runs
      if File.exist?(keychain_path)
        UI.message("Removing stale CI keychain from previous run...")
        sh("security delete-keychain #{Shellwords.escape(keychain_path)} 2>&1 || true")
        File.delete(keychain_path) if File.exist?(keychain_path)
      end

      create_keychain(
        name: keychain_name,
        password: keychain_password,
        default_keychain: false,
        unlock: true,
        timeout: 3600,
        lock_when_sleeps: false,
        add_to_search_list: true
      )

      # Ensure login.keychain-db and System.keychain remain in search list
      sh("security list-keychains -d user -s #{Shellwords.escape(keychain_path)} ~/Library/Keychains/login.keychain-db /Library/Keychains/System.keychain")

      # Set environment variables for match to use this keychain
      ENV["MATCH_KEYCHAIN_NAME"] = keychain_name
      ENV["MATCH_KEYCHAIN_PASSWORD"] = keychain_password

      sh("security set-keychain-settings -t 3600 -l #{Shellwords.escape(keychain_path)}")
      UI.message("CI keychain created (login.keychain-db preserved)")
    end

    # Validate that changelog exists for current version
    unless ChangelogHelper.validate_changelog_exists
      UI.user_error!("Please update CHANGELOG.md with an entry for the current version before releasing!")
    end

    # Ensure we have the latest certificates
    sync_certificates

    # Set partition list AFTER certificates are imported to prevent UI prompts
    if ENV['CI']
      ensure_ci_keychain_partition_list

      # Unlock keychain AGAIN after setting partition list
      keychain_path = get_ci_keychain_path
      keychain_password = ENV["MATCH_KEYCHAIN_PASSWORD"] || ""

      unlock_keychain(
        path: keychain_path,
        password: keychain_password,
        set_default: false,
        add_to_search_list: true
      )
    end

    # Get App Store Connect API key
    api_key = get_api_key

    # Get the latest TestFlight build number and increment
    # Read current build number from xcconfig
    xcconfig_path = "../Version.xcconfig"
    xcconfig_content = File.read(xcconfig_path)

    build_match = xcconfig_content.match(/CURRENT_PROJECT_VERSION = (\d+)/)
    if build_match.nil?
      UI.user_error!("Could not find CURRENT_PROJECT_VERSION in #{xcconfig_path}.")
    end
    current_build_number = build_match[1].to_i

    version_match = xcconfig_content.match(/MARKETING_VERSION = (.+)/)
    if version_match.nil?
      UI.user_error!("Could not find MARKETING_VERSION in #{xcconfig_path}.")
    end
    current_version = version_match[1].strip

    latest_testflight = latest_testflight_build_number(api_key: api_key)

    # Only increment if needed
    if latest_testflight >= current_build_number
      new_build_number = latest_testflight + 1
      # Update the xcconfig file
      new_content = xcconfig_content.gsub(
        /CURRENT_PROJECT_VERSION = \d+/,
        "CURRENT_PROJECT_VERSION = #{new_build_number}"
      )
      File.write(xcconfig_path, new_content)
      UI.message("Updated build number to #{new_build_number}")
    end

    # Use dynamic profile name from match environment variables
    profile_name = ENV["sigh_v2er.app_appstore_profile-name"] || "match AppStore v2er.app"

    # Ensure proper code signing
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "V2er.xcodeproj",
      team_id: ENV["ORG_TEAM_ID"] || ENV["TEAM_ID"],
      profile_name: profile_name,
      code_sign_identity: "Apple Distribution",
      targets: ["V2er-iOS"]
    )

    # Explicitly set provisioning profile for CI
    if is_ci
      update_project_provisioning(
        xcodeproj: "V2er.xcodeproj",
        profile: ENV["sigh_v2er.app_appstore_profile-path"],
        target_filter: "V2er-iOS",
        build_configuration: "Release"
      )
    end

    # Build the app
    build_ipa

    UI.success("iOS build completed: ./build/V2er.ipa")
  end

  desc "Upload built IPA to TestFlight or App Store"
  lane :upload_beta do
    # Get App Store Connect API key
    api_key = get_api_key

    # Locate the built IPA
    ipa_path = File.expand_path("../build/V2er.ipa")
    UI.user_error!("IPA not found at #{ipa_path}. Run build_beta first.") unless File.exist?(ipa_path)

    # Read current version from xcconfig
    xcconfig_path = "../Version.xcconfig"
    xcconfig_content = File.read(xcconfig_path)
    version_match = xcconfig_content.match(/MARKETING_VERSION = (.+)/)
    if version_match.nil?
      UI.user_error!("Could not find MARKETING_VERSION in #{xcconfig_path}.")
    end
    current_version = version_match[1].strip

    submit_for_review = ENV['SUBMIT_FOR_REVIEW'] == 'true'

    if submit_for_review
      # Upload to App Store Connect and submit for review
      UI.important("Submitting build for App Store review...")

      # Extract App Store "What's New" text from CHANGELOG.md
      changelog = ChangelogHelper.app_store_whats_new(current_version)

      # Set "What's New" on App Store version localizations via Spaceship API
      UI.message("Preparing App Store version localizations...")
      app = Spaceship::ConnectAPI::App.find("v2er.app")

      # Cancel any in-progress review submission (Apple only allows one at a time)
      begin
        submission = app.get_in_progress_review_submission(platform: Spaceship::ConnectAPI::Platform::IOS)
        if submission
          UI.important("Cancelling in-progress review submission...")
          submission.cancel_submission
          # Poll until cancellation takes effect
          poll_count = 0
          loop do
            break if app.get_in_progress_review_submission(platform: Spaceship::ConnectAPI::Platform::IOS).nil?
            poll_count += 1
            UI.message("Waiting for cancellation to take effect... (#{poll_count * 15}s)")
            break if poll_count >= 20  # 5 minute max
            sleep(15)
          end
          UI.success("Review submission cancelled")
        end
      rescue => e
        UI.important("Could not cancel existing submission: #{e.message}")
      end

      edit_version = app.get_edit_app_store_version(platform: Spaceship::ConnectAPI::Platform::IOS)

      if edit_version
        # Update "What's New" on existing editable version
        live_version = app.get_live_app_store_version
        live_metadata = {}
        if live_version
          live_version.get_app_store_version_localizations.each do |loc|
            live_metadata[loc.locale] = loc
          end
        end

        localizations = edit_version.get_app_store_version_localizations
        localizations.each do |loc|
          attrs = { whats_new: changelog }

          ref = live_metadata[loc.locale] || live_metadata.values.first
          if ref
            attrs[:description] = ref.description if loc.description.nil? || loc.description.to_s.strip.empty?
            attrs[:keywords] = ref.keywords if loc.keywords.nil? || loc.keywords.to_s.strip.empty?
            attrs[:support_url] = ref.support_url if loc.support_url.nil? || loc.support_url.to_s.strip.empty?
            attrs[:marketing_url] = ref.marketing_url if loc.marketing_url.nil? || loc.marketing_url.to_s.strip.empty?
          end

          UI.message("  Updating #{loc.locale} (#{attrs.keys.join(', ')})...")
          loc.update(attributes: attrs)
        end
        UI.success("Updated localizations for #{localizations.length} locale(s)")
      else
        UI.important("No editable version found on ASC — deliver will create version #{current_version}")
      end

      # Upload binary and submit for review
      upload_to_app_store(
        api_key: api_key,
        ipa: ipa_path,
        app_version: current_version,
        skip_metadata: edit_version != nil,
        skip_screenshots: true,
        submit_for_review: true,
        automatic_release: false,
        precheck_include_in_app_purchases: false,
        force: is_ci,
        run_precheck_before_submit: false,
        release_notes: edit_version ? nil : { "default" => changelog },
        submission_information: {
          add_id_info_uses_idfa: false,
          export_compliance_uses_encryption: false,
          export_compliance_encryption_updated: false
        }
      )

      UI.success("Build uploaded and submitted for App Store review!")
      UI.important("The build will be reviewed by Apple (usually 24-48 hours)")
      UI.important("The build is also available on TestFlight for beta testing")

      notification(
        title: "V2er iOS",
        subtitle: "Submitted for App Store Review",
        message: "Build has been uploaded and submitted for App Store review"
      ) if is_ci == false
    else
      # Upload to TestFlight only
      # NOTE: We skip waiting for build processing to avoid timeout issues.
      # IMPORTANT: Do NOT add a `changelog` parameter here — it causes fastlane to wait
      # for Apple's build processing even with skip_waiting_for_build_processing: true.
      begin
        upload_to_testflight(
          api_key: api_key,
          ipa: ipa_path,
          skip_submission: false,
          skip_waiting_for_build_processing: true,
          distribute_external: false,
          uses_non_exempt_encryption: false
        )
      rescue => e
        if e.message.include?("TLS") || e.message.include?("WILL RETRY")
          UI.important("altool reported a transient TLS error during upload, but the upload may have succeeded.")
          UI.important("Check App Store Connect / TestFlight to confirm. Error: #{e.message[0..200]}")
        else
          raise e
        end
      end

      UI.success("Build uploaded successfully to TestFlight!")
      UI.important("Build will be available for testing once Apple finishes processing (usually 5-30 minutes)")
      UI.important("You can distribute to testers using: fastlane distribute_beta")

      notification(
        title: "V2er iOS",
        subtitle: "Successfully uploaded to TestFlight",
        message: "Build has been uploaded and will be available for testing soon"
      ) if is_ci == false
    end
  end

  desc "Build and upload to TestFlight (convenience lane)"
  lane :beta do
    build_beta
    upload_beta
  end

  desc "Submit to App Store Review (legacy — builds first, use submit_review instead)"
  lane :release do
    # Ensure we have the latest certificates
    sync_certificates

    # Get App Store Connect API key
    api_key = get_api_key

    # Build the app
    build_ipa

    # Upload to App Store Connect
    upload_to_app_store(
      api_key: api_key,
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false,
      precheck_include_in_app_purchases: false
    )
  end

  desc "Submit latest build to App Store Review (no build required)"
  lane :submit_review do |options|
    # Get App Store Connect API key
    api_key = get_api_key

    # Read current version from Version.xcconfig
    xcconfig_path = "../Version.xcconfig"
    xcconfig_content = File.read(xcconfig_path)

    version_match = xcconfig_content.match(/MARKETING_VERSION = (.+)/)
    UI.user_error!("Could not find MARKETING_VERSION in Version.xcconfig") if version_match.nil?
    current_version = version_match[1].strip

    UI.important("Preparing to submit version #{current_version} for App Store review...")

    # Validate that changelog exists for current version
    unless ChangelogHelper.validate_changelog_exists
      UI.user_error!("Please update CHANGELOG.md with an entry for version #{current_version}!")
    end

    # Find the app on App Store Connect
    app = Spaceship::ConnectAPI::App.find("v2er.app")
    UI.user_error!("App 'v2er.app' not found on App Store Connect!") unless app

    # Cancel any in-progress review submission (Apple only allows one at a time)
    begin
      submission = app.get_in_progress_review_submission(platform: Spaceship::ConnectAPI::Platform::IOS)
      if submission
        UI.important("Cancelling in-progress review submission...")
        submission.cancel_submission
        # Poll until cancellation takes effect
        poll_count = 0
        loop do
          break if app.get_in_progress_review_submission(platform: Spaceship::ConnectAPI::Platform::IOS).nil?
          poll_count += 1
          UI.message("Waiting for cancellation to take effect... (#{poll_count * 15}s)")
          break if poll_count >= 20  # 5 minute max
          sleep(15)
        end
        UI.success("Review submission cancelled")
      end
    rescue => e
      UI.important("Could not cancel existing submission: #{e.message}")
    end

    # Get the editable App Store version (or create one)
    edit_version = app.get_edit_app_store_version(platform: Spaceship::ConnectAPI::Platform::IOS)
    unless edit_version
      UI.important("No editable version found, creating version #{current_version}...")
      edit_version = app.create_version!(
        platform: Spaceship::ConnectAPI::Platform::IOS,
        version_string: current_version
      )
    end

    UI.message("Using App Store version: #{edit_version.version_string}")

    # Find the latest processed build on App Store Connect
    target_build_number = options[:build_number]

    builds = Spaceship::ConnectAPI::Build.all(
      app_id: app.id,
      processing_state: "VALID",
      sort: "-uploadedDate",
      limit: 15
    )

    if builds.empty?
      UI.user_error!("No valid (processed) builds found on App Store Connect! Upload a build first using `fastlane beta`.")
    end

    if target_build_number
      latest_build = builds.find { |b| b.version == target_build_number.to_s }
      UI.user_error!("Build #{target_build_number} not found or not yet processed!") unless latest_build
    else
      latest_build = builds.first
    end

    UI.success("Selected build: #{latest_build.version} (uploaded: #{latest_build.uploaded_date})")

    # Attach the build to the App Store version
    begin
      edit_version.select_build(build_id: latest_build.id)
      UI.success("Attached build #{latest_build.version} to version #{edit_version.version_string}")
    rescue => e
      UI.important("Build attachment note: #{e.message}")
      UI.message("The build may already be attached — continuing...")
    end

    # Update "What's New" metadata on all localizations
    UI.message("Preparing App Store version localizations...")
    changelog = ChangelogHelper.app_store_whats_new(current_version)

    # Get metadata from the live (published) version as fallback for any missing fields
    live_version = app.get_live_app_store_version
    live_metadata = {}
    if live_version
      live_version.get_app_store_version_localizations.each do |loc|
        live_metadata[loc.locale] = loc
      end
    end

    localizations = edit_version.get_app_store_version_localizations
    localizations.each do |loc|
      attrs = { whats_new: changelog }

      # Fill in required fields from live version if missing
      ref = live_metadata[loc.locale] || live_metadata.values.first
      if ref
        attrs[:description] = ref.description if loc.description.nil? || loc.description.to_s.strip.empty?
        attrs[:keywords] = ref.keywords if loc.keywords.nil? || loc.keywords.to_s.strip.empty?
        attrs[:support_url] = ref.support_url if loc.support_url.nil? || loc.support_url.to_s.strip.empty?
        attrs[:marketing_url] = ref.marketing_url if loc.marketing_url.nil? || loc.marketing_url.to_s.strip.empty?
      end

      UI.message("  Updating #{loc.locale} (#{attrs.keys.join(', ')})...")
      loc.update(attributes: attrs)
    end
    UI.success("Updated localizations for #{localizations.length} locale(s)")

    # Submit for review via deliver (handles submission information properly)
    upload_to_app_store(
      api_key: api_key,
      skip_binary_upload: true,
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: true,
      automatic_release: false,
      precheck_include_in_app_purchases: false,
      force: true,
      run_precheck_before_submit: false,
      submission_information: {
        add_id_info_uses_idfa: false,
        export_compliance_uses_encryption: false,
        export_compliance_encryption_updated: false
      }
    )

    UI.success("Build #{latest_build.version} submitted for App Store review!")
    UI.important("The build will be reviewed by Apple (usually 24-48 hours)")

    notification(
      title: "V2er iOS",
      subtitle: "Submitted for App Store Review",
      message: "Build #{latest_build.version} submitted for review"
    ) if is_ci == false
  end

  desc "Create a new version on App Store Connect"
  lane :create_app_version do |options|
    api_key = get_api_key

    deliver(
      api_key: api_key,
      app_version: options[:version],
      skip_binary_upload: true,
      skip_metadata: false,
      skip_screenshots: true
    )
  end

  desc "Download metadata from App Store Connect"
  lane :download_metadata do
    api_key = get_api_key

    download_dsyms(api_key: api_key)

    deliver(
      api_key: api_key,
      skip_binary_upload: true,
      skip_screenshots: false,
      download_metadata: true,
      download_screenshots: true
    )
  end

  private_lane :ensure_ci_keychain_partition_list do
    # Get keychain password
    keychain_password = ENV["MATCH_KEYCHAIN_PASSWORD"] || ENV["CI_KEYCHAIN_PASSWORD"]

    unless keychain_password
      UI.important("No keychain password found, skipping partition list setup")
      next
    end

    # Use consistent keychain path
    resolved_keychain = get_ci_keychain_path

    # Verify keychain file exists
    unless File.exist?(resolved_keychain)
      UI.error("Keychain not found at: #{resolved_keychain}")
      UI.important("Available keychains:")
      sh("security list-keychains")
      raise "Keychain file not found: #{resolved_keychain}"
    end

    begin
      UI.message("Setting up keychain partition list...")
      UI.message("Keychain: #{resolved_keychain}")

      # Set partition list to allow codesign tools to access keys without prompting
      sh("security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k #{Shellwords.escape(keychain_password)} #{Shellwords.escape(resolved_keychain)} 2>&1")
      UI.success("Successfully updated key partition list")

      # Set timeout to prevent auto-lock
      sh("security set-keychain-settings -t 3600 -l #{Shellwords.escape(resolved_keychain)}")
      UI.message("Set keychain timeout to 3600 seconds (1 hour)")

      # Verify keychain settings
      UI.message("Verifying keychain settings:")
      sh("security show-keychain-info #{Shellwords.escape(resolved_keychain)} 2>&1 || true")
    rescue => e
      UI.error("Failed to setup keychain partition list")
      raise e
    end
  end

  # Clean up CI keychain and ensure login keychain is intact
  private_lane :cleanup_ci_keychain do
    next unless ENV['CI']

    keychain_path = get_ci_keychain_path
    login_keychain = File.expand_path("~/Library/Keychains/login.keychain-db")

    begin
      UI.message("Cleaning up CI keychain...")

      # Delete the temporary CI keychain
      if File.exist?(keychain_path)
        sh("security delete-keychain #{Shellwords.escape(keychain_path)} 2>&1 || true")
        File.delete(keychain_path) if File.exist?(keychain_path)
        UI.message("Deleted CI keychain: #{keychain_path}")
      end

      # Safety net: restore login.keychain-db if it was renamed by a stale setup_ci
      unless File.exist?(login_keychain)
        UI.important("login.keychain-db is missing! Attempting to restore from renamed copy...")
        renamed = Dir.glob(File.expand_path("~/Library/Keychains/login_renamed_*.keychain-db")).sort_by { |f| File.mtime(f) }.last
        if renamed
          FileUtils.mv(renamed, login_keychain)
          UI.success("Restored login.keychain-db from #{File.basename(renamed)}")
        else
          UI.important("No renamed keychain found, creating a new login.keychain-db")
          sh("security create-keychain -p '' #{Shellwords.escape(login_keychain)} 2>&1 || true")
        end
      end

      # Clean up any leftover login_renamed files
      Dir.glob(File.expand_path("~/Library/Keychains/login_renamed_*.keychain-db")).each do |f|
        File.delete(f)
        UI.message("Cleaned up stale renamed keychain: #{File.basename(f)}")
      end

      # Restore keychain search list to default state
      sh("security default-keychain -s #{Shellwords.escape(login_keychain)} 2>&1 || true")
      sh("security list-keychains -d user -s #{Shellwords.escape(login_keychain)} /Library/Keychains/System.keychain 2>&1 || true")
      UI.success("Keychain state restored")

    rescue => e
      UI.important("Keychain cleanup failed: #{e.message}")
    end
  end

  after_all do |lane|
    # Clean up temporary keychain after successful completion
    cleanup_ci_keychain
  end

  error do |lane, exception|
    # Clean up temporary keychain even on failure
    cleanup_ci_keychain

    notification(
      title: "V2er iOS - #{lane} failed",
      subtitle: "Error occurred",
      message: exception.message
    ) if is_ci == false
  end
end
