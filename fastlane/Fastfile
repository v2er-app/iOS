# Fastfile for V2er iOS app

default_platform(:ios)

platform :ios do
  # Helper method to get App Store Connect API key
  private_lane :get_api_key do
    # Check if running in CI or local
    if ENV["APP_STORE_CONNECT_API_KEY_KEY"]
      # CI environment with key file path
      key_content = File.read(ENV["APP_STORE_CONNECT_API_KEY_KEY"])
    elsif ENV["APP_STORE_CONNECT_API_KEY_CONTENT"]
      # Local environment with key content directly
      key_content = ENV["APP_STORE_CONNECT_API_KEY_CONTENT"]
    else
      # Try to read from standard location
      key_path = File.expand_path("~/.appstoreconnect/private_keys/AuthKey_#{ENV["APP_STORE_CONNECT_KEY_ID"]}.p8")
      if File.exist?(key_path)
        key_content = File.read(key_path)
      else
        UI.user_error!("App Store Connect API key not found. Please set APP_STORE_CONNECT_API_KEY_CONTENT environment variable or place the key at #{key_path}")
      end
    end

    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_KEY_ID"] || ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"] || ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
      key_content: key_content,
      in_house: false
    )
  end

  # Helper method for building the app
  private_lane :build_ipa do
    build_app(
      scheme: "V2er",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "v2er.app" => "match AppStore v2er.app"
        },
        teamID: ENV["TEAM_ID"]
      },
      export_team_id: ENV["TEAM_ID"],
      xcargs: "-allowProvisioningUpdates CODE_SIGN_STYLE=Manual",
      clean: true,
      output_directory: "./build",
      output_name: "V2er.ipa",
      verbose: true,
      buildlog_path: "./buildlog",
      silent: false
    )
  end

  desc "Sync certificates and provisioning profiles"
  lane :sync_certificates do
    match(
      type: "appstore",
      readonly: is_ci,
      app_identifier: "v2er.app",
      git_url: ENV["MATCH_GIT_URL"] || "git@github.com:graycreate/certificates-v2er-iOS.git",
      keychain_name: ENV["MATCH_KEYCHAIN_NAME"] || "login.keychain",
      keychain_password: ENV["MATCH_KEYCHAIN_PASSWORD"] || ""
    )
  end

  desc "Distribute existing build to beta testers"
  lane :distribute_beta do |options|
    # Get App Store Connect API key
    api_key = get_api_key

    # Get the build number to distribute (optional)
    build_number = options[:build_number]

    begin
      # Distribute to beta testers
      testflight(
        api_key: api_key,
        app_identifier: "v2er.app",
        skip_submission: false,
        distribute_external: true,  # Distribute to external testers (public beta)
        groups: ["Public Beta", "External Testers", "Beta Testers"],  # Public beta groups
        notify_external_testers: true,  # Send email notifications
        uses_non_exempt_encryption: false,
        submit_beta_review: true,  # Automatically submit for Beta review
        wait_for_uploaded_build: true,
        beta_app_description: "V2er is an elegant third-party client for V2EX forum",
        beta_app_feedback_email: "support@v2er.app",
        demo_account_required: false,
        beta_app_review_info: {
          contact_email: "support@v2er.app",
          contact_first_name: "V2er",
          contact_last_name: "Support",
          contact_phone: "+86 13800138000",
          notes: "This is a third-party client app for V2EX forum. No special account needed for testing."
        }
      )

      UI.success("âœ… Successfully distributed build to beta testers!")
    rescue => e
      UI.error("Failed to distribute: #{e.message}")
      UI.message("You may need to manually distribute the build in App Store Connect")
    end
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    # Ensure we have the latest certificates
    sync_certificates

    # Get App Store Connect API key
    api_key = get_api_key

    # Get the latest TestFlight build number and increment
    # Read current build number from xcconfig
    xcconfig_path = "../V2er/Config/Version.xcconfig"
    xcconfig_content = File.read(xcconfig_path)
    current_build_number = xcconfig_content.match(/CURRENT_PROJECT_VERSION = (\d+)/)[1].to_i

    latest_testflight = latest_testflight_build_number(api_key: api_key)

    # Only increment if needed
    if latest_testflight >= current_build_number
      new_build_number = latest_testflight + 1
      # Update the xcconfig file
      new_content = xcconfig_content.gsub(
        /CURRENT_PROJECT_VERSION = \d+/,
        "CURRENT_PROJECT_VERSION = #{new_build_number}"
      )
      File.write(xcconfig_path, new_content)
      UI.message("Updated build number to #{new_build_number}")
    end

    # Ensure proper code signing
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "V2er.xcodeproj",
      team_id: ENV["TEAM_ID"],
      profile_name: "match AppStore v2er.app",
      code_sign_identity: "iPhone Distribution",
      targets: ["V2er"]
    )

    # Explicitly set provisioning profile for CI
    if is_ci
      update_project_provisioning(
        xcodeproj: "V2er.xcodeproj",
        profile: ENV["sigh_v2er.app_appstore_profile-path"],
        target_filter: "V2er",
        build_configuration: "Release"
      )
    end

    # Build the app
    build_ipa

    # Upload to TestFlight
    upload_to_testflight(
      api_key: api_key,
      skip_submission: false,
      skip_waiting_for_build_processing: false,  # Wait for processing before distribution
      wait_processing_interval: 30,  # Check every 30 seconds
      wait_processing_timeout_duration: 900,  # Wait up to 15 minutes for processing
      distribute_external: true,  # Distribute to external testers (public beta)
      distribute_only: false,  # Upload and distribute in one action
      groups: ["Public Beta", "External Testers", "Beta Testers"],  # Public beta groups
      changelog: "Bug fixes and improvements",
      notify_external_testers: true,  # Send email notifications to external testers
      uses_non_exempt_encryption: false,  # Required for automatic distribution
      submit_beta_review: true,  # Automatically submit for Beta review
      beta_app_description: "V2er is an elegant third-party client for V2EX forum",
      beta_app_feedback_email: "support@v2er.app",
      demo_account_required: false,  # No demo account required
      beta_app_review_info: {
        contact_email: "support@v2er.app",
        contact_first_name: "V2er",
        contact_last_name: "Support",
        contact_phone: "+86 13800138000",
        notes: "This is a third-party client app for V2EX forum. No special account needed for testing."
      }
    )

    # Notify success
    notification(
      title: "V2er iOS",
      subtitle: "Successfully uploaded to TestFlight",
      message: "Build has been uploaded and will be available for testing soon"
    ) if is_ci == false
  end

  desc "Submit to App Store Review"
  lane :release do
    # Ensure we have the latest certificates
    sync_certificates

    # Get App Store Connect API key
    api_key = get_api_key

    # Build the app
    build_ipa

    # Upload to App Store Connect
    upload_to_app_store(
      api_key: api_key,
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false,
      precheck_include_in_app_purchases: false
    )
  end

  desc "Create a new version on App Store Connect"
  lane :create_app_version do |options|
    api_key = get_api_key

    deliver(
      api_key: api_key,
      app_version: options[:version],
      skip_binary_upload: true,
      skip_metadata: false,
      skip_screenshots: true
    )
  end

  desc "Download metadata from App Store Connect"
  lane :download_metadata do
    api_key = get_api_key

    download_dsyms(api_key: api_key)

    deliver(
      api_key: api_key,
      skip_binary_upload: true,
      skip_screenshots: false,
      download_metadata: true,
      download_screenshots: true
    )
  end

  error do |lane, exception|
    notification(
      title: "V2er iOS - #{lane} failed",
      subtitle: "Error occurred",
      message: exception.message
    ) if is_ci == false
  end
end